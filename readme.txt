How to use the codes in this directory
======================================

A) Generate mock data based on the instruction in mock_data_generation/v2/howto. The data generated with mock_data_generation are, namely,

	config.dat
	config.xyz
	experimental.dat 
	experimental_mock.dat 
	gmt_mock.dat
	gmt_mock.norm.dat    
	gmt_mock.norm.pdf

Note that the content in both experimental.dat, experimental_mock.dat files are identical. 
 
B). 

1. First use gen_dakota_mycal.in.sh to generate a box containing a specified number of spheres with fixed radius sprinkled randomly in the box. Basically, you need to edit the file gen_dakota_mycal.in.sh for the following parameters, namely,

	totalatomnumber 
	radius

so that the totalatomnumber and radius of the spheres tally with that generated from mock_data_generation in A) above. Use the detault values of the parameter 

	blr 
	
in gen_dakota_mycal.in.sh. Edit the variable 
	
	methodname 

or leave it blank. 

2. Read the instruction of how to use gen_dakota_mycal.in.sh. Execute gen_dakota_mycal.in.sh 

	./gen_dakota_mycal.in.sh

Follow the instruction as prompted in the terminal. A file dakota_mycal.in.$methodname will be generated, along with two others in the subdirectory templatedir/, namely, radius.dat and mycal.in.template. 

3. Manually craft the content of the generated file dakota_mycal.in.$methodname based on the instruction as epxlained in gen_dakota_mycal.in.sh. Edit the global optimization parameters in the method section of  dakota_mycal.in.$methodname. Example of parameters to edit include, for example,

    population_size 
    max_function_evaluations 
	num_offspring 
	num_parents  
	num_generations 
	other parameters

4. Place the files generated from mock_data_generation in A) into templatedir/.
	
5. In the presence of the instruction script dakota_mycal.in.$methodname (as properly edit in Step B.1 above), execute Dokota via the command line

	nohup dakota -i dakota_mycal.in.$methodname -o dakota_mycal.out > dakota_mycal.stdout & 

where dakota_mycal.in.$methodname is the name of the dakota input file, e.g., dakota_mycal.moga.3.in

Alternatively, use the run.sh file to perform the command via 

	./run.sh

You have to edit the variable dakota_mycalin in run.sh to suit your case. For example, you have to set in run.sh

	dakota_mycalin=dakota_mycal.moga.3.in

if you want to use Dakota to globally optimize the input script file dakota_mycal.moga.3.in. Note that the specified file (dakota_mycal.moga.3.in in this example) must exist in the present directory.
	
6. run.sh will perform global optimization on the following parameters specified in $dakota_mycalin: 

	x1, x2, x3, ..., x3N-2,x3N-1,x3N (N is the number of spheres)

{x1,x2,x3} are the x-, y- and z-coordinates for sphere labelled '1', 
{x4,x5,x6} are the x-, y- and z-coordinates for sphere labelled '2', 
...
{x3N-2,x3N-1,x3N} are the x-, y- and z-coordinates for sphere labelled 'N', 

All the N spheres share a commond radius (fixed and not to vary). The value of this common radius is manually set in Step B1 above, its value is explicitly exported into the external file templatedir/radius.dat.

7. Wait for the dakota optimization process to complete. Upon completion, a few output files from Dakota will be seen in the current directory. Most importantly, a completed version of the output file 'dakota_mycal.out'.

8. Upon completion of Step 7, perform checking on the results by executing 

	./compare_result_wrapper.sh

A new directory output/ will be produced to contain all the output results and analysis. The following are what compare_results.py does: 
	
	1. dakota_output.xyz will be produced by the line 
	
		check_objfn_v2b.sh 
		
	within compare_result_wrapper.py. dakota_output.xyz is the configuration obtained by Dakota as the best configuration which corresponding Cext curve has the smallest sigma (variance) as comparsed against that generated from mock_data_generation in Step A. Visualise dakota_output.xyz manually with VMD.
	
	2. Within compare_result_wrapper.py, a command line 
	
		python compare_result.py 
	
	will be executed. This will generate a file named gmt.dat based on dakota_output.xyz. gmt.dat contains a Cext vs. wavelength curve predicted by GMT based on dakota_output.xyz.
	
	3. Two files, sigma.csv and sigma.png will be generated by the line within compare_result_wrapper.sh:
	
		python visuallize_sigma.py
		
		sigma.csv and sigma.png contain the normalised values of Cext(gmt), Cext(exp) vs. wavelength. sigma.png also records the sigma value between the Cext curves as contained in gmt.dat and that in experimental.dat (contains the Cext curve as generated by mock_data_generation in step A).
	
	4. monitor_objf_sorted.dat, monitor_objf.dat, minsigmavswdir.dat will be generated within compare_result_wrapper.py. Both monitor_objf_sorted.dat, monitor_objf.dat contain all the values of objective functions encountered in the global optimization calculation. monitor_objf.dat contains unsorted while monitor_objf_sorted.dat sorted data. minsigmavswdir.dat contains the value of the best objective function. 
	
	5. sigma_workdir.png, a graphical visualisation of monitor_objf.dat will be generated by 
		
		./monitor_workdir.sh 
		
		within compare_result_wrapper.py. The value of the best objection function is also indicated in sigma_workdir.png.
	
	6. The low-laying structions, LLS, named according to the format such as LLS_5_4_22652_0.01587.xyz are generated by the line 
	
		python grep_LLS.py
	
	within compare_result_wrapper.py.		
	
	7. compare_result_wrapper.py will also produce bestradius.dat which contains the value of the radius obtained by dakota in the case radius is a common but variable to be optimized. If the common radius is not a variable to be optimized, the value in bestradius.dat is just the value specified in gen_dakota_mycal.in.sh.
	
	8. dakota_output_ro.xyz is the re-orientated version of dakota_output.xyz, while config_ro.xyz is the re-orientated version of config.xyz. These files are produced by 
	
		python visuallize_sigma.py 
	
	within compare_result_wrapper.py.

	13. si.dat, contains the value of the similarity index calculated based on config_ro.xyz and 	
		dakota_output_ro.xy, is produced by 
	
		python orientate_wrapper.py
		
	within compare_result_wrapper.py. orientate_wrapper.py converts config.xyz --> config_ro.xyz, dakota_output.xyz --> dakota_output_ro.xyz. Then, execution of 

		python similarity.py

	within compare_result_wrapper.py will read in config_ro.xyz, dakota_output_ro.xyz to produce the value of similarity index s2 in si.dat. A value of s2=1 means perfect similarity, and a value of s2 --> 0 means the two structures are very dissimilar. The execution of python similarity.py and orientate_wrapper.py are automatically performed in compare_result_wrapper.sh.
	
	14. summary.dat, summarises all essential information contained in the directory output/, including the datako input file used to generate them, i.e., dakota_mycal.in.$methodnam. From dakota_mycal.in.$methodnam, one can conveniently access the level of convergence and quality of the performance of the results for the input parameters in the global optimization method used. 	summary.dat is also a handy document to allow one to access whether the results produced by the dakota run has already achieved its goal. If sigma --> 0 and similarity index --> 1, that would mean an ideal solution has been found. In this scenario, dakota has successfully reproduced the configuration of the aggregates (which was not known to Dakota) that result in the Cext curve in experimental.dat. 
	



C) The following summarizes the information flow in the dakota-gmt package:

1. sigma between Cext (from mock experiment) and Cext (from GMT) 
===============================================================

                (via dakota-gmt )
random config -------------------> dakota_mycal.out 
								   |
                                   | (via check_objfn_v2.sh)
                                   |
								   dakota_output.xyz
                                   |
	   			                   | (via compare_results.py)
								   |
                                   |----> sigma.csv, sigma.png 
                                          (sigma.png compares the gmt.dat curve and 
                                           that in the Cext column of experimental.dat)

										   
2. similarity index between config.xyz (from mock experiment) and dakota_output.xyz (from GMT)  
==============================================================================================

                (via dakota-gmt )
random config --------------------> dakota_mycal.out 
									|
									| (via check_objfn_v2.sh)
									|
									dakota_output.xyz
													|
													|
													| --> compare visually (VMD) + calculate    
													|	  similarity index between them
known config fr mock_data_generation -> config.xyz -|



3. Discrepency between the ground truth radius in config.dat (from mock experiment) and that recorded in dakota_mycal.out (from GMT). This is relevant for the case where radius is set as a variable. 
=============================================================================================
 

                (via dakota-gmt )
random config -------------------> dakota_mycal.out ----
                                                        | --> compare the radius 
known config fr mock_data_generation -> config.dat -----


4. Discrepency in the common reflective indices (Real and Imaginary) in config.dat against that in dakota_mycal.out, which records the best-fit values as calculated by DAKOTA. This is relevant for the case where ReRI, ImRI of the spheres are set as variables.

	ReRI(from config.dat) vs. ReRI (from dakota_mycal.out)
	ImRI(from config.dat) vs. ImRI (from dakota_mycal.out)
