#! /bin/bash

## INSTRUCTION 

## Use this script to generate a fixed-length cubic box containing a number of spheres (specied by the variable totalatomnumber) initialised with random configuration and with a common radius (specified by the variable radius). 

## The sides of the box are set to the value of side=(2*radius)*(totalatomnumber)^(1/3)*(blr), where blr is set to a dafault value of 2. 

## This script will generate Section 1 of 5: Initialization of variables in a dakota input script. A full-fledge dakota input script that also contain Section 2 to Section 5 has to be manually crafted by following the following instruction. Additionally, this script will also generate two more files, namely, 
# templatedir/mycal.in.template and templatedir/radius.dat

# A set of ready-made sample dakota input scripts can be found in the directory sample_input_files/, e.g., 

# dakota_mycal.in.hybrid1.in  dakota_mycal.in.moga.2 dakota_mycal.in.rosen_opt_ego.in
# dakota_mycal.in.mogatest1_opt_sbo dakota_mycal.in.rosen_opt_sbo.in 
# dakota_mycal.in.hybrid2.in  dakota_mycal.in.mogatest2.in  
# dakota_mycal.in.hybrid3.in  dakota_mycal.in.rosen_opt_ea.in, etc.

# Use these samples as the reference template to design your desired dakota input script. Say if you want to use the sample dakota_mycal.in.hybrid2.in as the reference template. For the sake of easy reference, create a filename with a suffix that reflects the sample method of your choice, e.g., by setting

## methodname='hybrid4'
##
## As a results, a file in the naming convention 'dakota_mycal.in.$methodname' will be generated.  (i.e., 'dakota_mycal.in.hybrid4') upon execution of this script. 
##
## If you let amethodname blank, such as 
##
## methodname=
##
## A file 'dakota_mycal.in' will be generated instead.
## 
## Note that the generated files such as 'dakota_mycal.in.hybrid4' or 'dakota_mycal.in' contain only the information of variables. It does not contain the other sections required by Dakota. 

## Selectively (and smartly) cut and paste the non-variable content of dakota_mycal.in.hybrid2.in and  merge it with the output file generated by this script (i.e., 'dakota_mycal.in.hybrid4', which contains the variables section). Manually check and correct the content of dakota_mycal.in.hybrid4 to assure that the format and other information in it is correct. 

## You may very likely need to manually adjust the parameters of the optimization method specified in the generated file 'dakota_mycal.in.$methodname' (in this case, dakota_mycal.in.hybrid4).   dakota_mycal.in.hybrid4 is the Dakota input file you will use to run your global optimization. 

#### end of INSTRUCTION 



### Begin editing input parameters ####
# Set the value for the following quantities:
# 1 totalatomnumber (= positive integer representing the number of particles in the system). 
# 2 Radius of the atom (radius, a positive float in an assumed length unit)
# 3 method 
# 4 blr (side=(2*radius)*(totalatomnumber)^(1/3)*blr)
###############

totalatomnumber=14  		### default: 14
radius=100         	        ### default: 100.0
methodname=			        ### default: left blank 
blr=3				        ### default: 3

### End of editing input parameters ####

#### do not touch anything below this line #############
boxlength=$(echo $radius $totalatomnumber $blr | awk '{print 2*$1*($2**(1/3))*$3}')
xlo=$(echo $boxlength | awk '{print -0.5*$1}')
xhi=$(echo $boxlength | awk '{print 0.5*$1}')
ylo=$xlo; yhi=$xhi; 
zlo=$xlo; zhi=$xhi
#echo '$dimension, $totalatomnumberm$radius, $blr, $boxlength' $dimension $totalatomnumber $radius $blr $boxlength
#echo '$xlo $xhi $ylo $yhi $ylo $yhi' $xlo $xhi $ylo $yhi $ylo $yhi

###### generate dakota_mycal.in ##########################################
rm -rf XINIB.dat temp1.dat temp2.dat temp3.dat temp4.dat 
deltax=$(echo "$xhi $xlo" | awk '{print $1-$2}')
deltay=$(echo "$yhi $ylo" | awk '{print $1-$2}')
deltaz=$(echo "$zhi $zlo" | awk '{print $1-$2}')

for (( i=1; i<=$(( $totalatomnumber )); i++ ))
do  
	for (( j=1; j<=3; j++ ))
	do
	index=$(( (( 3*(( $i-1 )) )) + $j ))
	random=$( printf "0.%03d\n" $(( RANDOM % 1000 )) )
	
	if [ $j -eq 1 ]; then
#	echo $index
	tx=$(echo $random*$deltax | bc)
	x[$index]=$(echo "$xlo $tx" | awk '{print $1+$2}')
	cdv_lower_bounds[$index]=$xlo
	cdv_upper_bounds[$index]=$xhi    
#	echo 'j, index, x[$index]' $j, $index, ${x[$index]}
	fi
	
	if [ $j -eq 2 ]; then
	random=$( printf "0.%03d\n" $(( RANDOM % 1000 )) )
	ty=$(echo $random*$deltay | bc)
	x[$index]=$(echo "$ylo $ty" | awk '{print $1+$2}')
	cdv_lower_bounds[$index]=$ylo
	cdv_upper_bounds[$index]=$yhi
#	echo 'j, index, x[$index]' $j, $index, ${x[$index]}
	fi
	
	if [ $j -eq 3 ]; then
	random=$( printf "0.%03d\n" $(( RANDOM % 1000 )) )
	tz=$(echo $random*$deltaz | bc)
	x[$index]=$(echo "$zlo $tz" | awk '{print $1+$2}')
#	echo 'j, index, x[$index]' $j, $index, ${x[$index]}
	cdv_lower_bounds[$index]=$zlo
	cdv_upper_bounds[$index]=$zhi
	fi
	cdv_descriptor[$index]=x$index
	
	echo ${x[$index]} >> temp1.dat
	echo ${cdv_lower_bounds[$index]} >> temp2.dat
	echo ${cdv_upper_bounds[$index]} >> temp3.dat
	echo x$index >> temp4.dat
	done  
done

###### include radius as a parameter to tune #####
#index1=$(( $index + 1 ))
#factor_deltar=0.99 ### limit factor_deltar to be less than one to avoid occurance of negative radius
#fdeltar=$(echo $factor_deltar $radius | awk '{print $1*$2}')
#rlo=$(echo $radius $fdeltar | awk '{print $1-$2}')
#rhi=$(echo $radius $fdeltar | awk '{print $1+3*$2}')

#cdv_lower_bounds[$index1]=$rlo
#cdv_upper_bounds[$index1]=$rhi
#random=$( printf "0.%03d\n" $(( RANDOM % 1000 )) )
#deletarr=$(echo $rhi $rlo | awk '{print $1-$2}')
#x[$index1]=$(echo $rlo $deletarr $random | awk '{print $1+$2*$3}')

#echo ${x[$index1]} >> temp1.dat
#echo ${cdv_lower_bounds[$index1]} >> temp2.dat
#echo ${cdv_upper_bounds[$index1]} >> temp3.dat
#echo x$index1 >> temp4.dat
###### end of include radius as a parameter to tune #####

echo '# Section 1 of 5: Initialization of variables ###############' > temp0.dat
echo ' ' >> temp0.dat
echo 'variables' >> temp0.dat
echo 'continuous_design = '$(( 3*$totalatomnumber )) >> temp0.dat

cat temp1.dat | xargs > temp11.dat; echo "cdv_initial_point"|cat - temp11.dat > /tmp/out && mv /tmp/out temp11.dat; cat temp11.dat | xargs > temp1.dat

cat temp2.dat | xargs > temp22.dat; echo "cdv_lower_bounds"|cat - temp22.dat > /tmp/out && mv /tmp/out temp22.dat; cat temp22.dat | xargs > temp2.dat

cat temp3.dat | xargs > temp33.dat; echo "cdv_upper_bounds"|cat - temp33.dat > /tmp/out && mv /tmp/out temp33.dat; cat temp33.dat | xargs > temp3.dat

cat temp4.dat | xargs > temp44.dat; 
echo "cdv_descriptor"|cat - temp44.dat > /tmp/out && mv /tmp/out temp44.dat; 
cat temp44.dat | xargs > temp4.dat
printf '"%b" ' $(<temp4.dat) > temp4.dat ### note: quotation mark in the temp4.dat get washed away after the xargs operation. Hence have to add the double quotation sign via printf '"%b"'
echo ' ' >> temp4.dat
cat temp4.dat | awk '{$1="cdv_descriptor"} {print}' > temp.dat
echo ' ' >> temp.dat
echo '# End of Section 1 of 5: Initialization of variables ###############' >> temp.dat
echo ' ' >> temp.dat

mv temp.dat temp4.dat

cat temp0.dat temp1.dat temp2.dat temp3.dat temp4.dat > variables.dat
rm -rf temp0.dat temp1.dat temp2.dat temp3.dat temp4.dat temp11.dat temp22.dat temp33.dat temp44.dat temp.dat

if [ -z "$methodname" ];
then 
	ofn=dakota_mycal.in
else
	ofn=dakota_mycal.in.$methodname
fi

mv variables.dat $ofn ### dakota_mycal.in
#cat variables.dat method/$method  > $ofn ### dakota_mycal.in
rm -rf temp10

###### generate templatedir/mycal.template #########
totalcoordinate=$(echo $totalatomnumber*3 | bc)
rm -rf temp.dat
echo '** total number of varaibles' >> temp.dat
echo '** data begins from line 27 and onwards' >> temp.dat
echo '** the rest are all dummies' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '** ' >> temp.dat
echo '**' >> temp.dat

for (( c=1; c<=$(($totalcoordinate )); c++ ))
do
echo variable $c {x$c} >> temp.dat
#echo variable $c ${x[$c]} >> temp.dat
#eval TMP="\$c"; echo variable $c \x{$TMP}\ >> temp.dat
done
echo end >> temp.dat


if [ -d templatedir ]; then
	dummy=dummy
#	echo 'not mkidr'
else
	mkdir templatedir
#	echo 'mkdir templatedir'
fi
mv temp.dat templatedir/mycal.in.template
echo $radius > templatedir/radius.dat

### prompt on screen to notify initial parameters input
nvar=$(cat templatedir/mycal.in.template | awk 'END{print NR-1}');
nvar=$(cat templatedir/mycal.in.template | awk -v nvar=$nvar 'NR==nvar {print $2}');

echo 'The variables specified are as follows: '
echo ''
echo 'totalatomnumber:' $totalatomnumber
echo 'seed radius:' $radius
echo 'blr = integer to be multipled when defining boxlength' $blr 
echo 'boxlength:' $boxlength
echo 'method:' $method
echo 'total number of varaibles (continuous_design):' $nvar
echo 'variables:' 
echo ${x[@]}
echo 'lower bound of variables:' 
echo ${cdv_lower_bounds[@]}
echo 'upper bound of variables:' 
echo ${cdv_upper_bounds[@]}
echo ''

statement='Press [ENTER] to generate dakota_mycal.in and templatedir/mycal.in.template. \nPress [ESC] to abort' 
IFS=''
i0=5
echo -e $statement
echo "If dormant for $i0 seconds, dakota_mycal.in and templatedir/mycal.in.template will be removed or not be created"
for (( i="$i0"; i>0; i--)); do
	#echo ''
	printf "\r$i seconds remains"
	read -s -N 1 -t 1 key
	#if [ "$key" = $'\e' ]; then
	if [ "$key" == $'\x0a' ] ;then
        echo -e "\n[Enter] Pressed"
		echo 'dakota_mycal.in and templatedir/mycal.in.template created'
        #break
		exit 
	elif [ "$key" = $'\e' ]; then
        echo -e "\n[ESC] Pressed"
		rm -rf dakota_mycal.in templatedir/mycal.template
		echo 'dakota_mycal.in and templatedir/mycal.in.template removed or not be created'
                rm -rf templatedir/mycal.in.template dakota_mycal.in templatedir/mycal.in.template
		echo 'Run this script again if you want to generate mycal.in and templatedir/mycal.in.template'
        #break
		exit 
	fi
done

if [ ! "$key" == $'\x0a' ]; then
    echo -e "\nNo [ENTER] is Pressed"
	rm -rf dakota_mycal.in templatedir/mycal.template
	echo 'dakota_mycal.in and templatedir/mycal.in.template removed or not be created'
        rm -rf templatedir/mycal.in.template dakota_mycal.in templatedir/radius.dat
	echo 'Run this script again if you want to generate mycal.in and templatedir/mycal.in.template'
fi	
### end of prompt on screen to notify initial parameters input

###### end of generate dakota_mycal.in ##########################################


